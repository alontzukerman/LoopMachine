[{"C:\\GitHub\\Repositories\\LoopMachine\\src\\components\\ControlPanel.js":"1","C:\\GitHub\\Repositories\\LoopMachine\\src\\components\\Pad.js":"2","C:\\GitHub\\Repositories\\LoopMachine\\src\\context.js":"3","C:\\GitHub\\Repositories\\LoopMachine\\src\\App.js":"4","C:\\GitHub\\Repositories\\LoopMachine\\src\\index.js":"5","C:\\GitHub\\Repositories\\LoopMachine\\src\\components\\Records.js":"6","C:\\GitHub\\Repositories\\LoopMachine\\src\\audio_files\\index.js":"7","C:\\GitHub\\Repositories\\LoopMachine\\src\\Recorder.js":"8","C:\\GitHub\\Repositories\\LoopMachine\\src\\EventBus.js":"9"},{"size":5948,"mtime":1609000567058,"results":"10","hashOfConfig":"11"},{"size":2041,"mtime":1608730313286,"results":"12","hashOfConfig":"11"},{"size":82,"mtime":1608623379263,"results":"13","hashOfConfig":"11"},{"size":2145,"mtime":1609001040531,"results":"14","hashOfConfig":"11"},{"size":500,"mtime":1606656540069,"results":"15","hashOfConfig":"11"},{"size":1703,"mtime":1609001613241,"results":"16","hashOfConfig":"11"},{"size":752,"mtime":1608996345125,"results":"17","hashOfConfig":"11"},{"size":7152,"mtime":1608731517502,"results":"18","hashOfConfig":"11"},{"size":319,"mtime":1608591363929,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"lqyrql",{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"26","messages":"27","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"31"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"31"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\GitHub\\Repositories\\LoopMachine\\src\\components\\ControlPanel.js",["42"],"C:\\GitHub\\Repositories\\LoopMachine\\src\\components\\Pad.js",["43"],"C:\\GitHub\\Repositories\\LoopMachine\\src\\context.js",[],"C:\\GitHub\\Repositories\\LoopMachine\\src\\App.js",["44","45"],"import \"./App.css\";\nimport Pad from \"./components/Pad\";\nimport { useEffect, useState } from \"react\";\nimport styled from \"styled-components\";\nimport ControlPanel from \"./components/ControlPanel\";\nimport { TimeInSeconds } from \"./context\";\nimport { files } from \"./audio_files\";\nimport Records from \"./components/Records\";\nimport { eventBus } from \"./EventBus\";\nfunction App() {\n  const [isPlaying, setIsPlaying] = useState(false); // play indicator\n  const [timeInSeconds, setTimeInSeconds] = useState(0); // global timer in seconds\n  const [records, setRecords] = useState([]);\n\n  useEffect(() => {\n    // running timer as long isPlaying is on\n    if (isPlaying) {\n      const interval = setInterval(() => {\n        setTimeInSeconds((timeInSeconds + 0.01) % 8);\n      }, 10);\n      return () => clearInterval(interval);\n    } else return ;\n  });\n\n  return (\n    <TimeInSeconds.Provider value={{ timeInSeconds, setTimeInSeconds }}>\n      <StyledApp>\n        <Title>Welcome To The Looper</Title>\n        <StyledPadsContainer>\n          {files.map((file, i) => {\n            return <Pad isPlaying={isPlaying} audioFile={file} key={i} />;\n          })}\n        </StyledPadsContainer>\n        <Records records={records} />\n        <ControlPanel handleState={(bool) => setIsPlaying(bool)} />\n      </StyledApp>\n    </TimeInSeconds.Provider>\n  );\n}\n\n\n// styled components\nconst StyledApp = styled.div`\n  background-color: rgb(20, 20, 20);\n  height: 100vh;\n  width: 100vw;\n  position: relative;\n  overflow-y: hidden;\n  overflow-x: hidden;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  @media (max-width: 768px) {\n    & > div:nth-child(2) {\n      height: 350px;\n      width: 350px;\n    }\n  }\n  @media (max-width: 480px) {\n    & > div:nth-child(2) {\n      height: 330px;\n      width: 330px;\n    }\n  }\n`;\nconst Title = styled.h2`\n  text-align: center;\n  font-size: 2em;\n  color: #f9f9f9;\n  text-transform: uppercase;\n  letter-spacing: 3px;\n  margin: 50px 0;\n`;\nconst StyledPadsContainer = styled.div`\n  height: 400px;\n  width: 400px;\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-gap: 10px;\n`;\n\nexport default App;\n","C:\\GitHub\\Repositories\\LoopMachine\\src\\index.js",[],["46","47"],"C:\\GitHub\\Repositories\\LoopMachine\\src\\components\\Records.js",["48"],"import styled from \"styled-components\";\r\nimport React, { useEffect, useState } from \"react\";\r\nimport { eventBus } from \"../EventBus\";\r\nimport Record from \"./Record\";\r\nimport SyncAltIcon from \"@material-ui/icons/SyncAlt\";\r\nfunction Records() {\r\n  const [records, setRecords] = useState([]); // array of records\r\n  const [openRecords, setOpenRecords] = useState(false); // is display\r\n  useEffect(() => {\r\n    eventBus.on(\"newRecord\", ({ newRecord }) => { // waiting for new record\r\n      console.log(newRecord);\r\n\r\n      setRecords([...records,newRecord]);\r\n    });\r\n  }, []);\r\n  const handleMenu = () => { // change display state value\r\n    setOpenRecords(!openRecords);\r\n  };\r\n  return (\r\n    <RecordsContainer open={openRecords}>\r\n      <ToggleMenu hasRecord={records.length > 0} onClick={() => handleMenu()}>\r\n        <SyncAltIcon fontSize=\"large\" />\r\n      </ToggleMenu>\r\n      {records.map((record, i) => {\r\n        return <Record record={record} key={i} />;\r\n      })}\r\n    </RecordsContainer>\r\n  );\r\n}\r\n\r\n// styled components \r\nconst RecordsContainer = styled.div`\r\n  background-color: rgba(100, 100, 100, 0.6);\r\n  box-shadow: 0 0 3px 1px rgba(50,50,50,0.5);\r\n  color: #f9f9f9 ;\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  width: 200px;\r\n  display: flex;\r\n  align-items: center;\r\n  transition: transform 0.2s ease;\r\n  transform: ${(props) => (props.open ? \"translateX(0)\" : \"translateX(100%)\")};\r\n`;\r\n\r\nconst ToggleMenu = styled.div`\r\ncursor: pointer; \r\n  background-color: rgb(139, 82, 82);\r\n  width: 70px;\r\n  margin: 5px 0;\r\n  margin-left: -60px;\r\n  padding: 5px 0px 5px 10px;\r\n  display: ${props=>props.hasRecord ? 'flex' : 'none'};\r\n  align-items: center;\r\n`;\r\nexport default Records;\r\n","C:\\GitHub\\Repositories\\LoopMachine\\src\\audio_files\\index.js",[],"C:\\GitHub\\Repositories\\LoopMachine\\src\\Recorder.js",["49"],"import InlineWorker from \"inline-worker\";\r\n\r\nclass Recorder {\r\n  config = {\r\n    bufferLen: 4096,\r\n    numChannels: 2,\r\n    mimeType: \"audio/wav\",\r\n  };\r\n\r\n  recording = false;\r\n\r\n  callbacks = {\r\n    getBuffer: [],\r\n    exportWAV: [],\r\n  };\r\n\r\n  constructor(source, cfg) {\r\n    Object.assign(this.config, cfg);\r\n    this.context = source.context;\r\n    this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(\r\n      this.context,\r\n      this.config.bufferLen,\r\n      this.config.numChannels,\r\n      this.config.numChannels\r\n    );\r\n\r\n    this.node.onaudioprocess = (e) => {\r\n      if (!this.recording) return;\r\n\r\n      var buffer = [];\r\n      for (var channel = 0; channel < this.config.numChannels; channel++) {\r\n        buffer.push(e.inputBuffer.getChannelData(channel));\r\n      }\r\n      this.worker.postMessage({\r\n        command: \"record\",\r\n        buffer: buffer,\r\n      });\r\n    };\r\n\r\n    source.connect(this.node);\r\n    this.node.connect(this.context.destination); //this should not be necessary\r\n\r\n    let self = {};\r\n    this.worker = new InlineWorker(function () {\r\n      let recLength = 0,\r\n        recBuffers = [],\r\n        sampleRate,\r\n        numChannels;\r\n\r\n      this.onmessage = function (e) {\r\n        switch (e.data.command) {\r\n          case \"init\":\r\n            init(e.data.config);\r\n            break;\r\n          case \"record\":\r\n            record(e.data.buffer);\r\n            break;\r\n          case \"exportWAV\":\r\n            exportWAV(e.data.type);\r\n            break;\r\n          case \"getBuffer\":\r\n            getBuffer();\r\n            break;\r\n          case \"clear\":\r\n            clear();\r\n            break;\r\n        }\r\n      };\r\n\r\n      function init(config) {\r\n        sampleRate = config.sampleRate;\r\n        numChannels = config.numChannels;\r\n        initBuffers();\r\n      }\r\n\r\n      function record(inputBuffer) {\r\n        for (var channel = 0; channel < numChannels; channel++) {\r\n          recBuffers[channel].push(inputBuffer[channel]);\r\n        }\r\n        recLength += inputBuffer[0].length;\r\n      }\r\n\r\n      function exportWAV(type) {\r\n        let buffers = [];\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n        }\r\n        let interleaved;\r\n        if (numChannels === 2) {\r\n          interleaved = interleave(buffers[0], buffers[1]);\r\n        } else {\r\n          interleaved = buffers[0];\r\n        }\r\n        let dataview = encodeWAV(interleaved);\r\n        let audioBlob = new Blob([dataview], { type: type });\r\n\r\n        this.postMessage({ command: \"exportWAV\", data: audioBlob });\r\n      }\r\n\r\n      function getBuffer() {\r\n        let buffers = [];\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          buffers.push(mergeBuffers(recBuffers[channel], recLength));\r\n        }\r\n        this.postMessage({ command: \"getBuffer\", data: buffers });\r\n      }\r\n\r\n      function clear() {\r\n        recLength = 0;\r\n        recBuffers = [];\r\n        initBuffers();\r\n      }\r\n\r\n      function initBuffers() {\r\n        for (let channel = 0; channel < numChannels; channel++) {\r\n          recBuffers[channel] = [];\r\n        }\r\n      }\r\n\r\n      function mergeBuffers(recBuffers, recLength) {\r\n        let result = new Float32Array(recLength);\r\n        let offset = 0;\r\n        for (let i = 0; i < recBuffers.length; i++) {\r\n          result.set(recBuffers[i], offset);\r\n          offset += recBuffers[i].length;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function interleave(inputL, inputR) {\r\n        let length = inputL.length + inputR.length;\r\n        let result = new Float32Array(length);\r\n\r\n        let index = 0,\r\n          inputIndex = 0;\r\n\r\n        while (index < length) {\r\n          result[index++] = inputL[inputIndex];\r\n          result[index++] = inputR[inputIndex];\r\n          inputIndex++;\r\n        }\r\n        return result;\r\n      }\r\n\r\n      function floatTo16BitPCM(output, offset, input) {\r\n        for (let i = 0; i < input.length; i++, offset += 2) {\r\n          let s = Math.max(-1, Math.min(1, input[i]));\r\n          output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n        }\r\n      }\r\n\r\n      function writeString(view, offset, string) {\r\n        for (let i = 0; i < string.length; i++) {\r\n          view.setUint8(offset + i, string.charCodeAt(i));\r\n        }\r\n      }\r\n\r\n      function encodeWAV(samples) {\r\n        let buffer = new ArrayBuffer(44 + samples.length * 2);\r\n        let view = new DataView(buffer);\r\n\r\n        /* RIFF identifier */\r\n        writeString(view, 0, \"RIFF\");\r\n        /* RIFF chunk length */\r\n        view.setUint32(4, 36 + samples.length * 2, true);\r\n        /* RIFF type */\r\n        writeString(view, 8, \"WAVE\");\r\n        /* format chunk identifier */\r\n        writeString(view, 12, \"fmt \");\r\n        /* format chunk length */\r\n        view.setUint32(16, 16, true);\r\n        /* sample format (raw) */\r\n        view.setUint16(20, 1, true);\r\n        /* channel count */\r\n        view.setUint16(22, numChannels, true);\r\n        /* sample rate */\r\n        view.setUint32(24, sampleRate, true);\r\n        /* byte rate (sample rate * block align) */\r\n        view.setUint32(28, sampleRate * 4, true);\r\n        /* block align (channel count * bytes per sample) */\r\n        view.setUint16(32, numChannels * 2, true);\r\n        /* bits per sample */\r\n        view.setUint16(34, 16, true);\r\n        /* data chunk identifier */\r\n        writeString(view, 36, \"data\");\r\n        /* data chunk length */\r\n        view.setUint32(40, samples.length * 2, true);\r\n\r\n        floatTo16BitPCM(view, 44, samples);\r\n\r\n        return view;\r\n      }\r\n    }, self);\r\n\r\n    this.worker.postMessage({\r\n      command: \"init\",\r\n      config: {\r\n        sampleRate: this.context.sampleRate,\r\n        numChannels: this.config.numChannels,\r\n      },\r\n    });\r\n\r\n    this.worker.onmessage = (e) => {\r\n      let cb = this.callbacks[e.data.command].pop();\r\n      if (typeof cb == \"function\") {\r\n        cb(e.data.data);\r\n      }\r\n    };\r\n  }\r\n\r\n  record() {\r\n    this.recording = true;\r\n  }\r\n\r\n  stop() {\r\n    this.recording = false;\r\n  }\r\n\r\n  clear() {\r\n    this.worker.postMessage({ command: \"clear\" });\r\n  }\r\n\r\n  getBuffer(cb) {\r\n    cb = cb || this.config.callback;\r\n    if (!cb) throw new Error(\"Callback not set\");\r\n\r\n    this.callbacks.getBuffer.push(cb);\r\n\r\n    this.worker.postMessage({ command: \"getBuffer\" });\r\n  }\r\n\r\n  exportWAV(cb, mimeType) {\r\n    mimeType = mimeType || this.config.mimeType;\r\n    cb = cb || this.config.callback;\r\n    if (!cb) throw new Error(\"Callback not set\");\r\n\r\n    this.callbacks.exportWAV.push(cb);\r\n\r\n    this.worker.postMessage({\r\n      command: \"exportWAV\",\r\n      type: mimeType,\r\n    });\r\n  }\r\n\r\n  static forceDownload(blob, filename) {\r\n    let url = (window.URL || window.webkitURL).createObjectURL(blob);\r\n    let link = window.document.createElement(\"a\");\r\n    link.href = url;\r\n    link.download = filename || \"output.wav\";\r\n    let click = document.createEvent(\"Event\");\r\n    click.initEvent(\"click\", true, true);\r\n    link.dispatchEvent(click);\r\n  }\r\n}\r\n\r\nexport default Recorder;","C:\\GitHub\\Repositories\\LoopMachine\\src\\EventBus.js",[],{"ruleId":"50","severity":1,"message":"51","line":1,"column":29,"nodeType":"52","messageId":"53","endLine":1,"endColumn":38},{"ruleId":"54","severity":1,"message":"55","line":35,"column":6,"nodeType":"56","endLine":35,"endColumn":23,"suggestions":"57"},{"ruleId":"50","severity":1,"message":"58","line":9,"column":10,"nodeType":"52","messageId":"53","endLine":9,"endColumn":18},{"ruleId":"50","severity":1,"message":"59","line":13,"column":19,"nodeType":"52","messageId":"53","endLine":13,"endColumn":29},{"ruleId":"60","replacedBy":"61"},{"ruleId":"62","replacedBy":"63"},{"ruleId":"54","severity":1,"message":"64","line":15,"column":6,"nodeType":"56","endLine":15,"endColumn":8,"suggestions":"65"},{"ruleId":"66","severity":1,"message":"67","line":51,"column":9,"nodeType":"68","messageId":"69","endLine":67,"endColumn":10},"no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'time.timeInSeconds'. Either include it or remove the dependency array.","ArrayExpression",["70"],"'eventBus' is defined but never used.","'setRecords' is assigned a value but never used.","no-native-reassign",["71"],"no-negated-in-lhs",["72"],"React Hook useEffect has a missing dependency: 'records'. Either include it or remove the dependency array. You can also do a functional update 'setRecords(r => ...)' if you only need 'records' in the 'setRecords' call.",["73"],"default-case","Expected a default case.","SwitchStatement","missingDefaultCase",{"desc":"74","fix":"75"},"no-global-assign","no-unsafe-negation",{"desc":"76","fix":"77"},"Update the dependencies array to be: [isPlaying, isOn, time.timeInSeconds]",{"range":"78","text":"79"},"Update the dependencies array to be: [records]",{"range":"80","text":"81"},[1020,1037],"[isPlaying, isOn, time.timeInSeconds]",[571,573],"[records]"]